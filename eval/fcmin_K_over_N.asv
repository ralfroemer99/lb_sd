% Learn the nonlinear dynamics from measured data and design a sampled-data
% controller for the linearized system. 

% addpath '/home/ralf/mosek/10.0/toolbox/r2017aom'          % Ubuntu
% addpath 'C:\Program Files\Mosek\10.0\toolbox\r2017aom'    % Windows

close all
clear
rng('default')
warning('off','all')

% Where to save the data
save_path = "./data/";

% Whether to also compute optimized controllers
optimize_K = 1;

%% Specify system model and simulation
% System model
system = 'quad2D';
define_system

% Specify the factor between used sampling time and MSI
xi = 1./[1, 1.5, 2];

%% Train GP models
n_trials = 10;
Ts_max_vec = zeros(length(N_vec),n_trials);

%% Train models and compute minimum control frequency
disp('Starting model learning')

% Storage variables for the system matrices
A_all = zeros(n,n,length(N_vec),n_trials);
B_all = zeros(n,m,length(N_vec),n_trials);
Au_all = zeros(n,n,length(N_vec),n_trials);
Bu_all = zeros(n,m,length(N_vec),n_trials);
K_all = zeros(m,n,length(for_which_optimize),n_trials,length(xi));

for p = 1:n_trials
    disp(p)
    % Create noise-free samples
    switch system
        case 'quad1D'
            [z_obs,y_obs] = quad1D_samples(N_vec(end),params);
        case 'quad2D'
            [z_obs,y_obs] = quad2D_samples(N_vec(end),params);
    end

    % Add noise
    for i = 1:n
        y_obs(:,i) = y_obs(:,i) + sigma_n(i)*randn(N_vec(end),1);
    end

    % Gradually increase dataset and simulate each time
    for j = 1:length(N_vec)
        % Fit GP models
        gpr = cell(n,1);
        for i = 1:n
            % Take subset of training samples (growing dataset)
            gpr{i} = fitrgp(z_obs(1:N_vec(j),:),y_obs(1:N_vec(j),i),'KernelFunction',...
                'ardsquaredexponential','Sigma',sigma_n(i),'ConstantSigma',true);
        end

        % Initialize derivative predictions
        dmu = zeros(n+m,n);
        dSigma = zeros(n+m,n+m,n);

        % Compute derivatives
        for i = 1:n
            [sigma_f,L] = get_hyperparameters(gpr{i});
            L_inv = L^(-2);
            Z_train = gpr{i}.X;
            K_matrix = get_K(Z_train,sigma_f,L_inv,sigma_n(i));
            dmu(:,i) = get_dmu(sigma_f,L_inv,K_matrix,y_obs(1:N_vec(j),i),Z_train,[x_s,u_s]);
            dSigma(:,:,i) = get_dSigma(sigma_f,L_inv,K_matrix,Z_train,[x_s,u_s]);
        end

        [A,B] = dmu2AB(dmu,n);
        [Au,Bu] = dSigma2AB(dSigma,n);

        % Save system matrices
        A_all(:,:,j,p) = A;         B_all(:,:,j,p) = B;
        Au_all(:,:,j,p) = Au;       Bu_all(:,:,j,p) = Bu;

        % Transform uncertainty representation
        [H,E,E_u] = transform_uncertainty(Au,Bu);

        % Maximize sampling time
        eps_vec = logspace(-2,2,10);
        [Ts_max, K, Ts_vec] = max_Ts_norm_bounded(A,B,H,E,E_u,eps_vec);

        % Store MSI
        Ts_max_vec(j,p) = Ts_max;

        % Save control gain
        if 
        K_all(:,:,)
    end
end

% Compute how often the optimization problem could be solved
disp(Ts_max_vec);

% Plot minimum control frequency over N
if length(N_vec) > 1
    % Remove results where Ts_max = 0
    fc_min_mean = zeros(1,length(N_vec));
    fc_min_std = zeros(1,length(N_vec));
    for k = 1:length(N_vec)
        tmp = Ts_max_vec(k,:);
        tmp = tmp(tmp >= 0.01);
        fc_min_mean(k) = mean(1./tmp);
        fc_min_std(k) = std(1./tmp);
    end    
    figure()
    errorbar(N_vec,fc_min_mean,fc_min_std);
    xlabel('$N$','Interpreter','latex');
    ylabel('$f_{c,min}$','Interpreter','latex');
end

% Save data
save(save_path + "A_all",'A_all');
save(save_path + "B_all",'B_all');
save(save_path + "Au_all",'Au_all');
save(save_path + "Bu_all",'Bu_all');
save(save_path + "N_vec",'N_vec');
save(save_path + "Ts_max_vec",'Ts_max_vec');

pause(1)


if optimize_K
    disp('Starting controller optimization')
    %% Optimize Performance
    
    for q = 2:length(xi)
        disp(xi(q))
        for j = 1:length(for_which_optimize)        % Don't optimize for all N
            for p = 1:n_trials
                % Get system matrices and uncertainty
                A = A_all(:,:,for_which_optimize(j),p);
                B = B_all(:,:,for_which_optimize(j),p);
                Au = Au_all(:,:,for_which_optimize(j),p);
                Bu = Bu_all(:,:,for_which_optimize(j),p);
    
                % Transform uncertainty representation
                [H,E,E_u] = transform_uncertainty(Au,Bu);
    
                % Set sampling time
                Ts_max = Ts_max_vec(for_which_optimize(j),p);
                if Ts_max == 0
                    continue
                end
                Ts = xi(q) * Ts_max;
    
                % Maximize performance for a given sampling time
                eps_vec = logspace(-2,2,10);
                [eta, K, eta_vec] = min_J_norm_bounded(A,B,H,E,E_u,Ts,J1,J2,eps_vec);
    
                % Save control gain
                K_all(:,:,j,p,q) = K;
            end
        end
    end
    
    %% Save everything
    save(save_path + "K_all",'K_all');
    save(save_path + "xi",'xi');
    save(save_path + "for_which_optimize",'for_which_optimize');
end
